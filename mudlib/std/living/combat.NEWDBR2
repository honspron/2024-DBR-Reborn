//	/std/living/combat.c
//	from the Nightmare mudlib
//	code for combat
//	based upon the LOS combat by Buddha@TMI
//	DarkeLIB 0.1
//	Diewarzau 1994
// Modified by Geldron 031096 to fix HeartBeat prob
// Modified by Geldron 031096 to work with arena

#include <std.h>
#include <party.h>
#include <daemons.h>
#include <council.h>
#include <balance.h>
// Remove non-standard includes out of std files!
// Security and stability risk.

#pragma optimize
#define MAX_MELEE_WC	    20
#define MAX_ATTACK_BONUS    5
#define NEWBIE_LEVEL 3
#define KILL_RANGE 5
#define DEFAULT_PARALYZE_MESSAGE "You are stiff as stone."
#define UNDEAD_RACES ({"undead","skeleton","zombie","vampire","ghoul","ghost"})
#define CRIT_TYPES ({"A","B","C","D","E"})

// random damage from attacks - Glen
#define DECREASED_DAMAGE 1
// curve criticals toward lower ones - Glen
#define CRITICAL_CURVE 1

inherit BODY;
inherit SKILLS;

static int paralyzed, magic_round;
static int hunting;
int wimpy;
private string wimpydir;
private static object *attackers;
private static int any_attack;
private static int casting;
private static object *hunters;
private static object *pres_hunters;
private static mapping magic_protection;
private static string paralyze_message;
private static string target_thing;
private static object current;

int ok_to_kill(object targ);
void miss(string how, string type);
void set_casting(int x);
void set_paralyzed(int x, string drow);
void remove_paralyzed();
int query_paralyzed();
int query_casting();
int clean_up_attackers();
mapping get_damage(object weap);
string *crit_filter(string *target, string *filter);
string * crit_curve(string * criticals);
void run_away();
void send_messages(string *mesgs);
void set_wimpydir(string str);
void set_wimpy(int x);
string query_wimpydir();
int query_wimpy();
int kill_ob(object victim, int which);
int sight_adjustment(object who);
void continue_attack();
void update_current_skill();
void cease_all_attacks();
private string check_up(string limb);
void execute_attack();
void set_magic_protection(string limb, int x);
void add_magic_protection(mixed *info);
int query_magic_protection(string limb);
int query_magic_round();
string query_paralyze_message();
private void do_criticals(string *criticals);
int check_limbs_for_attack();
object party_leader(object att);
void stand_up();
void knock_down();
//used by execute attack **********
int protection, hits, pois, i, j, k, num_attacks, x, defendflag;
int num_rounds, parry_bonus, has_shield, skill, y;
//*************

int scale(int value, int numerator, int denominator){
return ((value * numerator) / denominator);
}

//  This function is used to initialize various variables

void init_attack() {
    init_complex_body();
    hunters = ({});
    attackers = ({});
    pres_hunters = ({});
    wimpydir = "out";
}

// Remove dead or non-existing objects out of the list of attackers
// Return true if there are still attackers around

int clean_up_attackers() {
    object *hunters_tmp, *attackers_tmp, *phunters_tmp;
    object first;
    int i;

    attackers_tmp = ({});
    hunters_tmp = ({});
    phunters_tmp = ({});
    i = sizeof(attackers);
    if(i) first = attackers[0];
    while(i--) {
	if(!attackers[i] || !objectp(attackers[i])) continue;
	if(attackers[i]->shadow_form() ||
	  this_object()->shadow_form()) {
	    if(environment(attackers[i]) == environment())
		phunters_tmp += ({ attackers[i] });
	    else
		hunters_tmp += ({ attackers[i] });
	    continue;
	}
	if(attackers[i]->query_ghost()) continue;
	if(environment(attackers[i]) != environment(this_object()))
	    hunters_tmp += ({ attackers[i] });
	else attackers_tmp += ({ attackers[i] });
    }
    i = sizeof(hunters);
    while(i--) {
	if(!hunters[i] || !objectp(hunters[i])) continue;
	if(hunters[i]->query_ghost()) continue;
	if(hunters[i]->shadow_form()) {
	    if(environment() == environment(hunters[i]))
		phunters_tmp += ({ hunters[i] });
	    else
		hunters_tmp += ({ hunters[i] });
	    continue;
	}
	if(environment(hunters[i]) == environment(this_object())) {
	    if(hunters[i]->query_invis() && !this_object()->query("see invis")) {
		phunters_tmp += ({ hunters[i] });
		continue;
	    }
	    if(hunters[i]->query_stealth() &&
	      skill_contest((int)hunters[i]->query_stealth(),
		(int)this_object()->query_skill("perception"), 1) == 1) {
		phunters_tmp += ({ hunters[i] });
		continue;
	    }
	    attackers_tmp += ({ hunters[i] });
	}
	else hunters_tmp += ({ hunters[i] });
    }
    i = sizeof(pres_hunters);
    while(i--) {
	if(!pres_hunters[i]) continue;
	if(environment(pres_hunters[i]) != environment()) {
	    hunters_tmp += ({ pres_hunters[i] });
	    continue;
	}
	if(pres_hunters[i]->query_stealth() ||
	  (pres_hunters[i]->query_invis() && !this_object()->query("see invis")) ||
	  pres_hunters[i]->shadow_form() ||
	  this_object()->shadow_form()) {
	    phunters_tmp += ({ pres_hunters[i] });
	    continue;
	}
	attackers_tmp += ({ pres_hunters[i] });
    }
    attackers = attackers_tmp;
    i = member_array(first, attackers);
    if(i > 0) {
	attackers[i] = attackers[0];
	attackers[0] = first;
    }
    hunters = hunters_tmp;
    pres_hunters = phunters_tmp;
    any_attack = sizeof(attackers);
    hunting = sizeof(hunters);
    return any_attack;
}

//  This isg the kill command.  If the victim is not yet attacked
//  then it is entered first into the list of victims.  If it
//  is already in the list, then it becomes the first entry

int kill_ob(object victim, int which) {
    object *borg_people,
    tobj; // this_object() -- assigned to reduce cpu
    int i;
    string nokillmsg;
    string to_owner, // this_object()->query_owner(); (cpu reduction)
    v_owner,  // victim->query_owner();        (cpu reduction)
    to_name,  // this_object()->query_name();  (cpu reduction)
    v_name;   // victim->query_name();         (cpu reduction)
    mixed *atrs;

    //  Add check to see if victim is already in attackers FIRST,
    //      to save cpu.
    //  -Diewarzau 3/31/96

    to_owner = (string)this_object()->query_owner();
    v_owner = (string)victim->query_owner();
    to_name = (string)this_object()->query_name();
    v_owner = (string)victim->query_name();

    if(load_object(CHAT_D)){
	if(victim && victim->query_attackers())
	    atrs = victim->query_attackers();

	if(this_object() != victim && 
	  (!atrs || !arrayp(atrs) ||
	    stringp(atrs) ||
	    member_array(this_object(), 
	      atrs) == -1)
	)
	    if(load_object(PK_D))
		PK_D->did_attack(this_object(), victim);    
    }

    if(victim && victim->query_property("no kill")) {
	if(!nokillmsg = victim->query_property("no kill msg"))
	    nokillmsg = "Sorry, but I will not fight you.";
	message("info", nokillmsg + "\n", this_player());
	return 0;
    }
    if(attackers)
	i = member_array(victim, attackers);
    else i = -1;
    if( i>-1 ) {
	if(attackers[0] == victim) {
	    if(!which)
		return 1;
	}
	attackers[i] = attackers[0];
	attackers[0] = victim;
	return 1;
    }
    if(victim == this_object()) return 0;
    if(victim->is_pet() && v_owner == to_name) return 0;
    if(this_object()->is_pet()) {
	if(to_owner == v_name || to_owner == v_owner) return 0;
    }
    borg_people = (object *)victim->query_attackers();
    if(victim->is_player() && !victim->query_ghost())
	HUNTING_D->add_hunter(v_name, this_object());
    if(!borg_people) borg_people = ({});
    if(member_array(this_object(), borg_people) == -1)
	if(!ok_to_kill(victim)) {
	    message("my_combat", sprintf(
		"Supernatural forces prevent you from attacking %s.",
		(string)victim->query_cap_name()),
	      this_object());
	    return 0;
	}
	/* changed from 0 to 1 to faciliate PK patch */
    if(this_object()->query_attacked()) return 1;
    if(attackers) i = member_array(victim, attackers);
    else i = -1;
    attackers = ({ victim }) + attackers;
    any_attack = 1;
    if(!which) victim->kill_ob(this_object(), 1);
    return 1;
}

int resist_ik(object what){
    int level;
    if(!what)return 0;
    if(!objectp(what))return 0;
    if(userp(what))return 0;
    level = what->query_level();
    if(level < 10)return 0;
    if(random(level + 4) > level)
	return 0;
    return (level * level / 2);
}

void set_attackers(object *what) {
    attackers = what;
    any_attack = 1;
}

//  Called from heart_beat
//  Here is where we see if we are dead or in combat

void continue_attack() {
    string attack_limb, lost_limb;
    string *nin;
    object *death, me;
    int n, xxx, exp;
    me = this_object();

    if(!environment(me) || me->query_ghost()) return;
    if(me->is_player() && !interactive(me)) return;
    // HB patch by glen 3-15-01
    if(attackers && sizeof(attackers) > 0 && objectp(attackers[0])){
	if(attackers[0]->query_ghost()){
	    attackers = ({});
	    return;
	}
	if((attackers[0]->query_hp() < 1 || attackers[0]->query_ghost()) && query_hp() > 0) return;
    }
    if(query_hp() < 1 && !me->query_ghost() ) {
	if(attackers) {
	    if(sizeof(attackers) && attackers[0]) {
		if(!me->is_player() || !attackers[0]->is_player())
		{
		    attackers[0]->add_hunt_exp((int)me->query_exp() / DEATH_EXP_MOD);
		}
		attackers[0]->add_kill((string)me->query_name());

	    }

	    // HB patch by glen 3-15-01
	    me->die(((attackers && sizeof(attackers) > 0 && objectp(attackers[0])) ? attackers[0] : 0));
	    attackers = ({});
	    return;
	}    
    }
    if(!any_attack && !hunting) return;
    if(!clean_up_attackers()) return;
    if(environment(this_object())->query_property("no attack")) return;
    if( random(500) < this_object()->query_stats("constitution")) stand_up();
    if((query_hp() * 100) / query_max_hp() < wimpy ) {
	run_away();
	return;
    }
    if(!query_paralyzed() && check_limbs_for_attack()) execute_attack();
    else if(!check_limbs_for_attack()) message("my_combat", "You may not attack with no wielding limbs!", this_object());
    else message("my_combat", query_paralyze_message(), this_object());
}

object party_leader(object att) {
    string party;
    object ret;

    if(!att->is_player()) return 0;
    if(att->query_ghost()) return 0;
    party = (string)PARTY_OB->party_member(att);
    if(!party) return 0;
    ret = (object)PARTY_OB->query_leader(party);
    if(ret && environment(ret) == environment(att) &&
      ret != att) return ret;
    return 0;
}

int calc_bonus_attacks(int gtype, int skill){
    int ret = 0;
    switch(gtype){
    case 3:
	if(skill > 150)
	    ret++;
	if(skill > 300)
	    ret++;
	if(skill > 500)
	    ret++;
	break;
    case 2:
	if(skill > 150)
	    ret++;
	if(skill > 300)
	    ret++;
	if(skill > 500)
	    ret++;
	if(skill > 800)
	    ret++;
	break;
    case 1:
	ret += skill / 125;
	break;
    default:
	ret += skill / 500;
	break;
    }
    return ret;
}

int query_ripost(int skill){
    int prob;
    if(skill < 1)prob = 0;
    else if(skill < 50)prob = 20;
    else if(skill < 100)prob = 40;
    else if(skill < 150)prob = 60;
    else if(skill < 200)prob = 80;
    else prob = 95;

    if(prob > random(100))
	return 1;
    return 0;
}

void execute_attack() {
    object *weapons, *a_weapons, ldr, me;
    string this_spell, res;
    mapping damage, tmp_res;
    string *tmp, *tmp2;
    string *criticals = ({}), *acrits = ({});
    mixed w_hit, tmp_mix;
    int dbonus;
    int single_attack;
    int z, p;
    //special combat tracker added to remove possible infinite recurssion
    int spec_com;
    protection = hits = pois = i = j = k = num_attacks = x = defendflag = 0;
    num_rounds = parry_bonus = has_shield = skill = y = 0;

    me = this_object();
    spec_com=0;
    if(!attackers || !sizeof(attackers) || !objectp(attackers[0])) return;
    if(objectp(attackers[0]))
	if(member_array(me, (object *)attackers[0]->query_attackers()) < 0)
	    attackers[0]->kill_ob(me, 1);
    if(!objectp(attackers[0]))
	return;
    ldr = party_leader(attackers[0]);
    if(ldr && ok_to_kill(ldr)) {
	num_rounds = query("free hits");
	if(num_rounds <= 0 && ldr->query_ghost() == 0 && skill_contest((int)ldr->query_skill("body block"), (2*(int)me->query_stats("strength")/3), 1) != 2 && (!ldr->query_property("no bodyblock"))) {
	    message("my_combat", "You prevent "+(string)me->query_cap_name()+" from attacking "+(string)attackers[0]->query_cap_name()+" with a fierce body block!", ldr);
	    message("my_combat", (string)ldr->query_cap_name()+" prevents you from attacking "+(string)attackers[0]->query_cap_name()+" with a fierce body block!", me);
	    message("my_combat", (string)ldr->query_cap_name()+" prevents "+(string)me->query_cap_name()+" from attacking you with a fierce body block!", attackers[0]);
	    message("other_combat", (string)ldr->query_cap_name()+" prevents "+(string)me->query_cap_name()+" from attacking "+(string)attackers[0]->query_cap_name()+" with a fierce body block!", environment(), ({ attackers[0], ldr, me }));
	    kill_ob(ldr, 1);
	}
    }
    if(magic_round) {
	if(!query("concentrate"))
	    return;
	if(random(100) >= (int)me->query_skill("concentrate"))
	    return;
	if(random(100) < (5 - ((int)me->query_skill("concentrate")/20))){
	    message("info", "%^RED%^%^BOLD%^You accidentally interrupt your spell!", me);
	    if(objectp(me->query_casting()))
		((object)me->query_casting())->remove();
	    me->set_casting(0);
	}
    }
    
    num_attacks = 1;
    num_rounds = 1;

    num_rounds += (int)me->query_num_rounds();
    
    if(!num_rounds)
	num_rounds = 1;
    
    weapons=distinct_array(me->query_wielded());
    
    if(sizeof(weapons) > 1)
	num_rounds += sizeof(weapons)-1;

    if(num_attacks < 1)
	if(me->query_skill("martial arts") >= 100)
	    num_attacks = me->query_skill("martial arts") / 200 + 1;
	else
	    num_attacks = 1;

    if(random(100) < (int)me->query_skill("whirlwind attack"))
	num_rounds++;

    if(me->query_haste())
	for(i=0; i < me->query_haste() || i < 2; i++)
	    num_attacks++;

    if(me->query("riposting") || me->query("single attack")){
	num_rounds = 1;
	num_attacks = 1;
	single_attack = 1;
    }

    // Shield check moved to here to save processing - TM 072601
    has_shield = 0;
    tmp = (string *)attackers[0]->query_limbs();
    k = sizeof(tmp);
    while(k--){
	if(member_array("shield",(string *)attackers[0]->query_armour(tmp[k])) != -1)
	    has_shield = 1;
    }
    // Encumbrance check moved here to save processing - TM 072601
    if((int)attackers[0]->query_max_internal_encumbrance() <= 0)
	attackers[0]->set_max_internal_encumbrance(1);

    // Guild check moved here to save processing - TM 072601
    if(sizeof(this_object()->query_wielded()))
	skill = this_object()->query_skill(this_object()->query_wielded()[0]->query_type());
    else
	skill = this_object()->query_skill("melee");
    
    if(!single_attack)
	num_attacks += calc_bonus_attacks(me->query_guild_type(), skill);
    
    while(num_rounds > 4) 
	num_rounds--;

    while(num_attacks > 10) 
	num_attacks--;

    if(num_attacks <= 0) 
	num_attacks = 1;
    
    if(num_rounds <= 0) 
	num_rounds = 1;

    for(j=0; j<num_rounds;j++)
	for(i=0; i<num_attacks; i++){
	    // Speed crit stuff, added to reduce processing time and number of bonus attack from speed crits
	    // TM - 072601
	    z = this_object()->query("bonus speed attacks");
	    if(z > 5)
		z = 5;
	    this_object()->set("bonus speed attacks", 0);
	    for(p=0;p<=z;p++){
		defendflag = 0;
		target_thing = (string)attackers[0]->return_target_limb();
		if(!sizeof(weapons))
		    current = 0;
		else
		    current = weapons[i%sizeof(weapons)];
		a_weapons = distinct_array(attackers[0]->query_wielded());
		if(current)
		    skill = query_skill((string)current->query_type());
		else
		    skill = query_skill("melee");

		if(sizeof(query_wielding_limbs()) < 1)
		    write("you may not attack with no wielding limbs");

		if(current && current->query_hit_bonus())
		    skill += (int)current->query_hit_bonus();
		skill += ((int)me->query_skill("attack")/50);

		if(me->query_intox())
		    skill -= (int)me->query_intox() / 10;

		if(current && !(int)me->query_property("ambidextry")) 
		{
		    x = 0;
		    tmp = query_wielding_limbs();
		    k = sizeof(tmp);
		    while(k--)
			if(current == query_weapon(tmp[k]) && tmp[k] == (string)me->query_property("handedness"))
			    x = 1;
		    if(!x && query_skill("offhand training") < 150)
			skill -= 75 - (query_skill("offhand training")/2);
		}

		skill -= (int)attackers[0]->sight_adjustment(me);

		if(query_body_position() != "standing")
		    skill = skill / 3;

		if(current && num_attacks > 1 && sizeof(weapons) > 1 && query_skill("dual attack") < 150)
		    skill -= 150-(query_skill("dual attack")/2);
		if(a_weapons)
		{
		    k = sizeof(a_weapons);
		    parry_bonus = 0;
		    while(k--)
			if(a_weapons[k]->query_parry_bonus() > parry_bonus)
			    parry_bonus = a_weapons[k]->query_parry_bonus();
		}


		// parry
		if(check_limbs_for_attack() && skill - random(100) <
		  (int)attackers[0]->query_skill("parry") 
		  + parry_bonus - random(100) 
		  + ((int)query_skill("ripost") / 3)
		  && (int)attackers[0]->query_wielding_limbs()) {
		    // check for riposte
		    if(query_ripost((int)attackers[0]->query_skill("ripost"))){
			miss("ripost", (current)?(string)current->query_type() : 0);
			attackers[0]->set("riposting", 1);
			attackers[0]->execute_attack();
			attackers[0]->set("riposting", 0);
			continue;
		    }
		    miss("parry", (current)?(string)current->query_type() : 0);
		    defendflag = 1;
		    continue;
		}  else
		    // dodge
		if(skill - random(100) <
		  (int)attackers[0]->query_skill("dodge") - to_int(percent(
		      (int)attackers[0]->query_internal_encumbrance(),
		      (int)attackers[0]->query_max_internal_encumbrance())) / 5 -
		  random(100) && !attackers[0]->query_paralyzed()) {
		    miss("dodge",(current)?(string)current->query_type() :
		      0);
		    defendflag = 1;
		    continue;
		} else if(has_shield && (skill -
		    random(100) < (int)attackers[0]->query_skill("block") -
		    random(100))) {
		    miss("block",(current)?(string)current->query_type() :
		      0);
		    defendflag = 1;
		    continue;
		} else
		    damage = get_damage(current);
		if(!damage || !keys(damage)) continue;
		if(current) {
		    w_hit = current->query_hit();
		    if(functionp(w_hit)) w_hit = evaluate(w_hit, attackers[0]);
		    else if(stringp(w_hit)) message("my_combat",w_hit,me);
		}
		tmp = keys(damage);
		if(w_hit && mapp(w_hit))
		    tmp = distinct_array(tmp + keys(w_hit));
		x = 0;
		for(k=0;k<sizeof(tmp);k++) {
		    if(mapp(w_hit) && !undefinedp(w_hit[tmp[k]])) {
			if(undefinedp(damage[tmp[k]])) damage[tmp[k]] = w_hit[tmp[k]];
			else damage[tmp[k]] += w_hit[tmp[k]];
		    }
		    if(current && num_attacks > 1)
			damage[tmp[k]] -= 29-(query_skill("dual attack")/4);
		    if(tmp2 = (string *)attackers[0]->
		      query_property("invulnerability")) {
			if(current && stringp(current->query_property("material_name"))
			  &&(!current->query_property("enchantment") ||
			    (int)current->query_property("enchantment") < 0)) {
			    if(member_array((string)current->query_property("material_name"),
				tmp2) >= 0)
				damage[tmp[k]] = -1000;
			}
			else if(!current && member_array("default", tmp2) >= 0)
			    damage[tmp[k]] = -1000;
		    }
		    tmp_res = (mapping)attackers[0]->
		    query_property("physical resistance");
		    if(tmp_res && current && stringp(current->query_property("material_name"))
		      && (!current->query_property("enchantment") ||
			(int)current->query_property("enchantment") < 0)) {
			tmp2 = keys(tmp_res);
			if((y = member_array((string)current->query_property("material_name"),
			      tmp2)) > -1 && damage[tmp[k]] > 0)
			    damage[tmp[k]] = to_int(to_float(100+damage[tmp[k]]) *
			      to_float(100-tmp_res[tmp2[y]]) / 100.0) - 100;
		    }
		    if(tmp_res && !current && member_array("default", keys(tmp_res))
		      >= 0) {
			damage[tmp[k]] = to_int(to_float(100+damage[tmp[k]]) *
			  to_float(100-tmp_res["default"]) /
			  100.0)-100;
		    }
		    if(w_hit && intp(w_hit)) damage[tmp[k]] += w_hit;
		    hits = random(100)+1;
		    protection = (int)attackers[0]->query_current_protection(
		      target_thing, tmp[k]);
		    res = (string)DAMAGE_D->attack_result(sprintf("%d %d %d",
			hits,damage[tmp[k]], protection));

		    // damage bonus
		    dbonus = (int)DAMAGE_D->damage_bonus(damage[tmp[k]], protection);
		    if(me->query_property("trace"))
			write("damage bonus " + dbonus);
		    x += dbonus;

		    switch(explode(res," ")[0]) {
		    case "DAMAGE":
			sscanf(res,"DAMAGE %d",hits);
			x += hits;
			break;
		    case "CRITICAL":
			x += 10;
			hits = member_array(replace_string(res, "CRITICAL ", ""),
			  CRIT_TYPES);
			hits = (hits < 0)? 0 : ((hits > 4)? 4:hits);
			if(tmp[k])
			    criticals += ({ lower_case(tmp[k]) +
			      " " + CRIT_TYPES[hits] });
			break;
		    }
		}
		if(!criticals || !sizeof(criticals) || x > 0) {
		    send_messages((string *)DAMAGE_D->attack_message(sprintf(
			  "%d %s %s:%s", x, (current)?(string)current->query_verb() :
			  "hit", (string)me->query_name(), (string)
			  attackers[0]->query_name())));
		    if(x > 3 && current && current->query_poisoning()) {
			pois = random((int)current->query_poisoning()+1);
			attackers[0]->add_poisoning(pois);
			current->add_poisoning(-pois); }
		    // COMBAT PATCH by glen
		    if(x < 1)
			x = 1;
		    x = (int)attackers[0]->do_damage(target_thing, x);
		    if(x > me->query_statistic("big hit"))
			me->set_statistic("big hit", x);
		}
	    }
	}
    if(x > 0) {
	if(sizeof(this_object()->query_wielded())) {
	    this_object()->query_wielded()->decay();
	    me->add_hunt_exp(x/ATTACK_DAMAGE_EXP_MOD);
	}
    }
    // weapon hit "hook" function
    // weapon_hit(at, from, damage, number hits);
    if(!single_attack)
	attackers[0]->weapon_hit(attackers[0], me, x, num_rounds * num_attacks);
    if(!criticals || x < 2) return;
    acrits = ({});
    criticals = distinct_array(criticals);
    while(sizeof(criticals) > (num_attacks * num_rounds)) criticals -= ({ criticals[random(sizeof(criticals))] });
    if(CRITICAL_CURVE)
	criticals = crit_curve(criticals);
    do_criticals(criticals);
    if(current && (string *)current->query_auto_critical() && defendflag < 1)
	acrits = (string *)current->query_auto_critical();
    acrits = distinct_array(acrits);
    acrits = crit_filter(acrits, criticals);
    if(x > 0)
	attackers[0]->check_on_limb(target_thing);
    if(me->query_property("trace")){
	for(i = 0; i < sizeof(acrits); i++)
	    write("auto crit: " + acrits[i]);
    }
    do_criticals(acrits);
    if(me->query_property("tcrits")) message("info", "Crits: "+sizeof(criticals)+" ACrits: "+sizeof(acrits)+" X: "+x, find_player("thrace"));

}

// convert string to int
int cpower(string str)
{
    if(lower_case(str) == "a")return 1;
    if(lower_case(str) == "b")return 2;
    if(lower_case(str) == "c")return 3;
    if(lower_case(str) == "d")return 4;
    if(lower_case(str) == "e")return 5;
    return 0;
}

// convert int to string
string tpower(int x)
{
    if(x == 1)return "A";
    if(x == 2)return "B";
    if(x == 3)return "C";
    if(x == 4)return "D";
    if(x == 5)return "E";
    return "X";
}

int max(int x, int y){
    if(x > y)
	return x;
    return y;
}

int min(int x, int y){
    if(x < y)
	return x;
    return y;
}

int valid_type(string str){
    if(member_array(str, DAMAGE_TYPES) != -1)
	return 1;
    return 0;
}

// crit reduction curve function
int do_curve(int x){
    int a,i;
    if(x < 1)
	return x;
    for(i = 0; i < x; i++)
	if(random(100) > 70 || i < 3)
	    a++;
    return a;
}

// filter target by filter
string *crit_curve(string *crits)
{
    int i, j, x;
    mapping filt = ([]);
    string type, let;
    string *keys;

    for(i = 0; i < sizeof(crits); i++){
	sscanf(crits[i], "%s %s", type, let);
	filt += ([ type : max(cpower(let), filt[type]) ]);
}
keys = keys(filt);
for(i = 0; i < sizeof(keys); i++)
    filt[keys[i]] = do_curve(filt[keys[i]]);

for(i = 0; i < sizeof(crits); i++){
    sscanf(crits[i], "%s %s", type, let);
    if(valid_type(type))
	crits[i] = type +" "+ tpower(filt[type]);
    else
	crits[i] = type +" "+ let;
}

return crits;
}

// filter target by filter
string *crit_filter(string *target, string *filter)
{
    int i, j;
    mapping filt = ([]);
    string type, let;

    if(this_player()->query_property("trace")){
	for(i = 0; i < sizeof(target); i++)
	    write("pre target: " + target[i]);
    }
    if(this_player()->query_property("trace")){
	for(i = 0; i < sizeof(filter); i++)
	    write("filter: " + filter[i]);
    }

    for(i = 0; i < sizeof(filter); i++){
	sscanf(filter[i], "%s %s", type, let);
	filt += ([ type : max(cpower(let), filt[type]) ]);
}

for(i = 0; i < sizeof(target); i++){
    sscanf(target[i], "%s %s", type, let);
    if(valid_type(type))
	target[i] = type +" "+ tpower(min(cpower(let), filt[type]));
    else
	target[i] = type +" "+ let;
}

for(i = 0; i < sizeof(target); i++){
    sscanf(target[i], "%s %s", type, let);
    if(let == "X"){
	target = exclude_array(target, i);
	i--;
    }
}
if(this_player()->query_property("trace")){
    for(i = 0; i < sizeof(target); i++)
	write("post target: " + target[i]);
}
return target;
}

private void do_criticals(string *criticals) {
    int x, i, j, m, amt, dur, roll;
    string *tmp, *crit_words, what, what2, *tmp2;
    object ob;
    object *targ_armour, me;
    int k, l, foc_att; 
    mixed tmp_crits;
    function special_func;
    string *msg;
    int ik = 0;
    int res_ik;
    int enh;
    me = this_object();
    for(i=0; i< sizeof(criticals);i++) {
	amt = 0;
	sscanf(criticals[i],"%s %s", what2, what);
	tmp_crits = (int)attackers[0]->query_property("enhance criticals");
	if(attackers[0]->query_strong_arm() && intp(tmp_crits))
	    tmp_crits += (int)attackers[0]->query_strong_arm();
	if(tmp_crits && intp(tmp_crits))
	    amt += tmp_crits / 2;
	else if(tmp_crits && mapp(tmp_crits)) {
	    tmp = keys(tmp_crits);
	    x = member_array(what2, tmp);
	    if(x >= 0 && intp(tmp_crits[tmp[x]])) amt += 
		tmp_crits[tmp[x]] / 2;
	}
	if(current) {
	    tmp_crits = current->query_enh_critical() / 2;
	    if(tmp_crits && intp(tmp_crits))
		amt += tmp_crits;
	    else if(tmp_crits && mapp(tmp_crits)) {
		tmp = keys(tmp_crits);
		x = member_array(what2,tmp);
		if(x >= 0) {
		    amt += tmp_crits[tmp[x]];
		}
	    }
	}
	else if(attackers[0] && attackers[0]->query_skill("martial arts")){
	    tmp_crits = (attackers[0]->query_skill("martial arts") / 75);
	    if(tmp_crits && intp(tmp_crits))
		amt += tmp_crits;
	    else if(tmp_crits && mapp(tmp_crits)) {
		tmp = keys(tmp_crits);
		x = member_array(what2,tmp);
		if(x >= 0) {
		    amt += tmp_crits[tmp[x]];
		}
	    }
	}

	if(member_array((string)attackers[0]->query_race(), UNDEAD_RACES) >= 0 &&
	  what2 == "holy") amt += 2;
	/*	    if(wizardp(me) && (string)me->
		      getenv("TRACE") == "on")
			message("info", "HIT LOCATION: "+target_thing, me);
	*/

	targ_armour = (object *)attackers[0]->query_armour_ob(target_thing);
	//  if(targ_armour)
	if(pointerp(targ_armour)) {
	    j = sizeof(targ_armour);
	    while(j--) {
		if((mixed)targ_armour[j]->query_enh_critical())
		    tmp_crits = (mixed)targ_armour[j]->query_enh_critical() / 2;
		if(tmp_crits && intp(tmp_crits))
		    amt += (int)targ_armour[j]->query_enh_critical() / 2;
		else if(tmp_crits && mapp(tmp_crits)) {
		    tmp = keys(tmp_crits);
		    x = member_array(what2,tmp);
		    if(x >= 0) {
			amt += tmp_crits[tmp[x]];
		    }
		}
	    }
	}
	// used for presence and things, negates armour and weapon
	// modifiers

	if(attackers[0] && attackers[0]->persistent_crits() == 1)
	    amt = 0;

	what = capitalize(what);
	dur = member_array(what,CRIT_TYPES);
	dur += amt;
	if(dur > 4) dur = 4;
	if(dur < 0) continue;
	criticals[i] = sprintf("%s %s",what2, CRIT_TYPES[dur]);
	roll = random(100)+1;

	msg = (string *)DAMAGE_D->query_msg(criticals[i],
	  roll, sprintf("%s:%s",(string)me->query_name(),
	    (string)attackers[0]->query_name()));

	tmp = (string *)DAMAGE_D->query_result(criticals[i], roll);

	// IK reduction code by glen
	res_ik = resist_ik(attackers[0]);
	for(m = 0; m < sizeof(tmp); m++)
	    if(strsrch(tmp[m], "KILL") != -1){
		if(res_ik > 0)
		    tmp[m] = "DAMAGE " + res_ik;
	    }
	    // end ik reduction code

	send_messages(msg);
	if(!tmp || !sizeof(tmp)) continue;
	else for(j=0;j<sizeof(tmp);j++) {
		switch(explode(tmp[j]," ")[0]) {
		case "DAMAGE":
		    if(!sscanf(tmp[j],"DAMAGE %d",amt)) break;
		    if(target_thing) amt = (int)attackers[0]->
			do_damage(target_thing, amt, 1);
		    else amt =(int)attackers[0]->do_damage((target_thing = 
			    (string)attackers[0]->
			    return_target_limb()),amt,1);
		    if(amt > 0) {
			me->add_hunt_exp(amt/ATTACK_DAMAGE_EXP_MOD);
			attackers[0]->check_on_limb(target_thing);
		    }
		    break;
		case "STUN":
		    if(!sscanf(tmp[j],"STUN %d",dur)) break;
		    attackers[0]->set_paralyzed(dur*2,
		      "%^MAGENTA%^You are stunned and cannot attack!");
		    break;
		case "BLEED":
		    if(!sscanf(tmp[j],"BLEED %d",l)) break;
		    k = attackers[0]->query_property("bleeding");
		    attackers[0]->set_property("bleeding", k + l);
		    break;
		case "KILL":
		    attackers[0]->set_hp(-1);
		    break;
		case "SPECIAL_RESULT":
		    if(sscanf(tmp[j],"SPECIAL_RESULT %s %s", what, what2) != 2)
			continue;
		    if(!me || !attackers[0]) continue;
		    call_other(what, what2, me, attackers[0]);
		    break;
		case "LIMB_LOSS":
		    crit_words = explode(tmp[j]," ");
		    l = sizeof(crit_words);
		    if(l == 1 || (l == 2 && crit_words[l-1] == "cripple"))
			what = (string)attackers[0]->return_target_limb();
		    else if(l >= 2) {
			if(crit_words[1] == "non_fatal") {
			    k = sizeof((tmp2 = (string *)attackers[0]->
				query_limbs())) - 1;
			    if(k >= 0) what = tmp2[k-1];
			    while((string)attackers[0]->query_reference(what) ==
			      "FATAL" && k--)
				what = tmp2[k];
			    if((string)attackers[0]->query_reference(what) ==
			      "FATAL") what = 0;
			} else {
			    if(crit_words[l-1] == "cripple" && l > 2)
				what = implode(crit_words[1..l-2], " ");
			    else
				what = implode(crit_words[1..l-1], " ");
			    what = (string)attackers[0]->sub_limb(what);
			}
		    }
		    if(!what) break;
		    if(l >= 2 && crit_words[l-1] == "cripple" && attackers && attackers[0] && what) {
			if(attackers[0]->query_crippled(what)) break;
			amt = (int)attackers[0]->cripple_limb(what, "cripple");
		    } else if(attackers && attackers[0] && what) {
			if((int)attackers[0]->query_max_dam(what) < 1)
			    break;
			amt = (int)attackers[0]->cripple_limb(what, "sever");
			k = attackers[0]->query_property("bleeding");
			attackers[0]->set_property("bleeding", k + 25);
		    }
		    break;
		case "CONT_DAMAGE":
		    if(sscanf(tmp[j],"CONT_DAMAGE %d %d",amt,dur) != 2)
			break;
		    if(!target_thing) target_thing = (string)attackers[0]->
			return_target_limb();
		    DAMAGE_D->init_cont_damage(attackers[0], dur, amt,
		      "%^MAGENTA%^You take damage from "+
		      "your wounds!");
		case "SKILL_MOD":
		    if(sscanf(tmp[j],"SKILL_MOD %s %d %d", what, amt, dur) != 3)
			break;
		    attackers[0]->add_skill_bonus(what,amt);
		    attackers[0]->delay_skill_mod(dur*2,
		      -amt, what);
		    break;
		}
	    }
    }
    return;
}

void delay_skill_mod(int dur, int amt, string what) {
    call_out("remove_skill_mod", dur, ([ "what" : what,
	"amount" : amt]));
    return;
}

void remove_skill_mod(mapping info) {
    if(!info || !mapp(info)) return;
    this_object()->add_skill_bonus(info["what"], info["amount"]);
    return;
}

void stop_hunting() {
    hunting = 0;
    hunters = ({});
}
void cease_all_attacks() {
    attackers = ({});
    any_attack = 0;
}

object query_current_attacker() {
    if(!sizeof(attackers)) return 0;
    else return attackers[0];
}

void knock_down(){
    object spell;
    if(spell = this_object()->query_casting()){
	message("info", "%^YELLOW%^Being knocked down stops your casting!", this_object());
	spell->remove();
	this_object()->set_casting(0);
	this_object()->set_magic_round(0);
    }
    if(this_object()->query_body_position() != "held")
	this_object()->set_body_position("sitting");
}

void stand_up(){
    if(this_object()->query_body_position() != "standing"
      && !this_object()->query_paralyzed()){
	this_object()->set_body_position("standing");
	message("my_combat", "You stand up", this_object());
	message("other_combat", 
	  this_object()->query_cap_name() + " stands up.",
	  all_inventory(environment(this_object())), this_object());
    }
}

void run_away() {
    string *str;

    str = (string *)environment(this_object())->query_exits();
    if(!str || !sizeof(str)) {
	message("my_combat", "There is nowhere to run!!!", this_object());
	return;
    }
    message("my_combat", "You run away.", this_object());
    if(member_array(wimpydir, str) != -1) this_object()->force_me(wimpydir);
    else this_object()->force_me(str[random(sizeof(str))]);
}

void set_wimpydir(string str) {
    if(!stringp(str)) return;
    wimpydir = str;
}

void set_wimpy(int x) { wimpy = x; }

string query_wimpydir() { return wimpydir; }

int query_wimpy() { return wimpy; }

mapping get_damage(object weap) {
    mapping ret_val;
    int attack, melee, i;
    string *tmp, dmg_type;
    int x;

    ret_val = ([]);
    melee = query_skill("melee");
    attack = query_skill("attack");
    if(!weap) {
	if(mapp(this_object()->query_property("melee damage")))
	    ret_val += (mapping)this_object()->query_property("melee damage");
	else
	    dmg_type = (string)this_object()->query_property("melee damage");

	if(this_object()->query_skill("martial arts")&& (int)
	  this_object()->query_skill("martial arts") > 10)
	    ret_val += ([ "strike" : 
	      (int)this_object()->query_skill("martial arts") ]);

    if(mapp(ret_val)) 
	tmp = distinct_array(keys(ret_val) + ({ dmg_type }));
    else 
	tmp = ({ dmg_type });

    i = sizeof(tmp);
    while(i--) {
	if(undefinedp(ret_val[tmp[i]])) ret_val[tmp[i]] = 0;

	if(intp(this_object()->query_skill("martial arts")))
	    ret_val[tmp[i]] +=  melee / 5 + (int)this_object()->query_stats("strength") / 4;
	ret_val[tmp[i]] = scale(ret_val[tmp[i]],
	  attack + (int)this_object()->query_skill("martial arts"),
	  100);
	if(DECREASED_DAMAGE)
	    ret_val[tmp[i]] = random(ret_val[tmp[i]]) + 1;
    }   
}
else {
    ret_val = weap->query_all_wc();
    tmp = keys(ret_val);
    for(i=0;i<sizeof(tmp);i++) {
	ret_val[tmp[i]] +=
	(int)this_object()->query_stats("strength")/4 +
	(int)this_object()->query_stats("dexterity")/6 +
	(int)this_object()->query_stats("constitution")/20;

	ret_val[tmp[i]] +=
	scale(ret_val[tmp[i]],
	  attack,
	  100);
	if(DECREASED_DAMAGE)
	    ret_val[tmp[i]] = random(ret_val[tmp[i]]) + 1;
    }
}
return ret_val;
}

void set_casting(int x) { casting = x; }

int query_casting() { return casting; }

void set_magic_protection(string limb, int x) {
    if(!magic_protection) magic_protection = ([]);
    if(!limb) magic_protection["overall"] = x;
    else magic_protection[limb] = x;
}

void add_magic_protection(mixed *info) {
    string limb;
    int time, x, i;

    if(sizeof(info) != 3) return;
    limb = info[i];
    x= info[1];
    time = info[2];
    if(!magic_protection) magic_protection = ([]);
    if(!limb) magic_protection["overall"] += x;
    else magic_protection[limb] += x;
    if(time > 0) call_out("add_magic_protection", time, ({ limb, -x, 0 }) );
}

int query_magic_protection(string limb) {
    if(!magic_protection) return 0;
    if(!limb) return magic_protection["overall"];
    else return (magic_protection["overall"] + magic_protection[limb]);
}

void send_messages(string *mesgs) {
    if(sizeof(mesgs) != 3) mesgs = ({ "BUG in message sender",
	  "BUG in message sender", "BUG in message sender" });
    if(strlen(mesgs[0]))
	message("my_combat",mesgs[0],this_object());
    if(strlen(mesgs[1]))
	message("other_combat",mesgs[1],environment(this_object()),
	  ({ this_object(), attackers[0] }));
    if(strlen(mesgs[2]))
	message("my_combat",mesgs[2],attackers[0]);
    return;
}

object *query_hunted() { return hunters + pres_hunters; }

object *query_attackers() {
    if(!attackers) return ({});
    if(!sizeof(attackers)) return ({});
    return attackers;
}

int sight_adjustment(object who) {
    int elight, ret, csa;

    ret = 0;
    if(!pointerp(attackers) || !sizeof(attackers)) return 0;
    elight = effective_light(who);
    if(elight >6 || elight < 1)
	ret = random(20);
    if((int)this_object()->query_property("light") > 0)
	ret -= random(10);
    else if((int)this_object()->query_property("light") < 0)
	ret += random(10);
    if((int)this_object()->query_invis() && !(int)who->query("see invis")) {
	ret += 60 - ((int)who->query_skill("perception") / 3);
    }
    return ret;
}

void miss(string how, string type) {
    string you, me;
    string *missed;

    you = (string)attackers[0]->query_cap_name();
    me = query_cap_name();
    switch(lower_case(how)) {
    case "block":
	send_messages(({ "Your attack is blocked by "+you+"'s shield.",
	    you+" blocks "+me+"'s attack deftly.",
	    "You skillfully block "+me+"'s attack with your shield." }));
	break;
    case "ripost":
	send_messages(({ you+" riposts against your attack.",
	    you+" riposts "+me+"'s attack.",
	    "You ripost against "+me+"'s attack." }));
	break;
    case "parry":
	send_messages(({ you+" skillfully parries your feeble attack.",
	    you+" bats "+me+"'s attack aside with a skillful parry.",
	    "You deftly parry "+me+"'s attack." }));
	break;
    case "dodge":
	send_messages(({ you+" dodges your attack.",
	    you+" sidesteps "+me+"'s attack.",
	    "You dodge "+me+"'s attack." }));
	break;
    default:
	send_messages(({ "You miss "+you+".",me+" misses "+you+".",
	    me+" misses you." }));
    }
    return;	
}

void set_paralyzed(int x, string drow) {
    int res;
    object spell;

    if((int)this_object()->query_paralyzed() > 0) return;
    if(wizardp(TO)) {
	message("my_action", "Your Immortality just saved you from being "
	  "paralyzed.", this_object());
	return;
    }
    if(this_object()->query("no stun")) {
	message("info", "%^CYAN%^%^BOLD%^You resist being stunned!",
	  this_object());
	return;
    }
    res = (int)this_object()->query_skill("resist stun");
    if(res) {
	res = res + random(res/4)-random(res/4);
	if(res >= 10)
	    message("info", "%^MAGENTA%^%^BOLD%^You resist "+res+
	      "% of the stun!", this_object());
	x -= res / 15;
    }
    if(x <= 0) return;
    if(spell = this_object()->query_casting()){
	message("info", "%^YELLOW%^Being stunned stops your casting!", this_object());
	spell->remove();
	this_object()->set_casting(0);
	this_object()->set_magic_round(0);
    }
    if(!drow)
	paralyze_message = DEFAULT_PARALYZE_MESSAGE;
    else
	paralyze_message = drow;
    paralyzed = 1;
    call_out("remove_paralyzed", x);
}

string query_paralyze_message() { return paralyze_message; }

int query_paralyzed() { return paralyzed; }

void remove_paralyzed() { 
    if(!this_object()) return;
    remove_call_out("remove_paralyzed");
    paralyzed = 0;
    message("my_combat", "%^YELLOW%^YOU CAN MOVE AGAIN!!!%^RESET%^", this_object());
}

int mobility(int magic) {
    int ret;

    if(magic) ret = 70 - (int)this_object()->query_stats("wisdom");
    else {
	ret = to_int(percent(query_internal_encumbrance(),query_max_internal_encumbrance()))/4;
	ret += 35-(int)this_object()->query_stats("dexterity");
    }
    if(ret > 50) ret = 50;
    if(ret < 0) ret = 0;
    return ret;
}

int query_current_protection(string target_thing, string type) {
    int prot, tmp;

    if(!type || member_array(type,DAMAGE_TYPES) < 0)
	type = DAMAGE_TYPES[0];
    prot = (int)this_object()->query_ac(target_thing, type)+query_skill("defense")/15;
    return prot;
}

void set_magic_round(int x) { magic_round = x; }

int query_magic_round() { return magic_round; }

int ok_to_kill(object targ) {
    int vic_level;
    string str, title;

    if(targ->is_invincible()) return 0;
    if(wizardp(this_object())) return 1;
    if(member_array(query_name(), COUNCIL) != -1) return 1;
    if(!this_object()->is_player() || !targ->is_player()) return 1;
    return 1;
}

int check_limbs_for_attack() {
    string *which_limbs;
    string refi;
    int i, num;

    if(this_object()->query_ghost()) return 0;
    which_limbs = (string *)this_object()->query_wielding_limbs();
    if(!sizeof(which_limbs)) return 0;
    i = sizeof(which_limbs);
    num = 0;
    while(i--) {
	if(this_object()->query_crippled(which_limbs[i])) continue;
	refi = (string)this_object()->query_reference(which_limbs[i]);
	if(refi && this_object()->query_crippled(refi)) continue;
	num++;
    }
    return sizeof(which_limbs);
}

